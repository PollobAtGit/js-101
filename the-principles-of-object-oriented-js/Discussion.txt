
# JavaScript has five primitive types. They are followings:
    ## Number
    ## String
    ## Boolean
    ## null
    ## undefined

# All of the above primitive types has a literal representation as well as a object representation.

# An JS object is an un-ordered list of properties consisting of name & values

# Functions themselves are reference types in JS

# Objects in JS are simply dictionary/hash table with property keys and their corresponding values

# JS is a garbage collected language. If any reference type object has no usage/has no reference associated with it
    then that object will be collected by garbage collector. Deferencing can be done just by setting null to
    that variable

# Built-in types in JS are:
    RegExp
    Function
    Object
    Array
    Date
    Error

# String wrapper object can hold individual properties similar to any other JS object. Following will work:

    {code: JS}

        var strWrapperObj = new String('STRING');
        strWrapperObj.lastName = 'OBJ';
        console.log(strWrapperObj.lastName);//'OBJ'

        var str = 'STRING';
        str.lastName = 'OBJ';
        console.log(str.lastName);//undefined

    {code}

# When we assign/define a property for a JS primitive type (String, Number or Boolean), under the hood JS interpreter defines that property for a wrapper object
    of that type. So the property is properly defined but that object is de-referenced immediately & also code doesn't have a handle to that wrapper
    object (as created internally) so that property is lost (will produce undefined) when we try to access that property with the context of the primitive type
    variable

# instanceof works properly for reference types only

# When using bind() method we have the option to set function argument later when it is really invoked. Also we can bind
the arguments with function parameters when we are invoking bind to get the reference of the function

# Conceptually, call/apply/bind can convert a standalone function (without any context, no method) to a method

# Adding a property to an object creates a OWN property

# Adding property to an object using dot/bracket notation is almost like invoking [[put]] method on a
dictionary & assigning value to a property is almost like invoking [[set]] method on a dictionary

# If [[set]] is invoked on dictionary key that exists already than the previous value will simply be replaced
with the new one

# Following is NOT a better pattern to check if a property exists in an object or not. Because this statement
will evaluate the object property. If that property does exist & the returned value is falsy (null, undefined,
NaN, false, 0) than the if condition will be evaluated to true, so existing property will be defined again
replacing the previous one.

    {code:js}

        //If property doesn't exist
        if(!obj.propertyName) {
            //Define the property
        }

    {code}

# Following is a better approach to evaluate if a property exist or not because 'in' keyword doesn't
evaluate the property value so only checking is done on that property's existence

    {code:js}

        //If property doesn't exist
        if(!"propertyName" in obj) {
            //Define property
        }

    {code}
